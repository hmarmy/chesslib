
import com.github.bhlangonijr.chesslib.game.Game;
import com.github.bhlangonijr.chesslib.game.GameResult;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

 public enum OpeningHandler {

  CK("xxx"), LND("xxxx"), SLV("tttt");

  private PositionDao dao;

  private OpeningHandler(String a) {
   
  }

  public PositionDao getDAO() {
    if (dao==null) {
      dao = new PositionDao(toString());
    }
    return dao;
  }

  public static OpeningHandler findHandler(Game g) {
    String eco = g.getEco();

    if (eco == null) {
      System.out.println("INVALID ECO : " + eco);
      return null;
    }
    eco = eco.trim();
    if (eco.length() < 3) {
      System.out.println("B INVALID ECO : " + eco);
      return null;
    }

    //CK:B10–B19
    if (eco.startsWith("B1"))
      return CK;

    //LND D02, A46, A48
    if (eco.matches("D02|A46|A48"))
      return LND;

    //SLV  D10–D19
    if (eco.startsWith("D1"))
      return SLV;

    return null;
  }

  public static void commitAll() throws SQLException{
    for (OpeningHandler h : OpeningHandler.values()) {
      if (h.dao!=null && h.dao.cx!=null) {
         h.dao.cx.commit();        
      }
    }
  }
  
  ;

  class PositionDao {
    final String name;

    private Connection cx;
    private PreparedStatement pstmtW, pstmtD, pstmtB, pstmtM;

    public PositionDao(String name) {
      this.name = name;
    }

    private void createTables(boolean drop) throws SQLException {
      Connection c = getConnection();
      DB.createTable(c, "POS", createPOSTableSQL, drop);
      DB.createTable(c, "POS_MOVES", createPOS_MOVESTableSQL, drop);
    }

    public Connection getConnection() throws SQLException {
      if (cx == null) {
        cx = DB.connect(name, false, true);
        createTables(false);
      }
      return cx;
    }

    PreparedStatement getStatment(GameResult result) throws SQLException {
      switch (result) {
      case WHITE_WON:
        if (pstmtW == null) {
          pstmtW = getConnection().prepareStatement(sqlW, Statement.RETURN_GENERATED_KEYS);
        }
        return pstmtW;
      case DRAW:
        if (pstmtD == null) {
          pstmtD = getConnection().prepareStatement(sqlD, Statement.RETURN_GENERATED_KEYS);
        }
        return pstmtD;
      case BLACK_WON:
        if (pstmtB == null) {
          pstmtB = getConnection().prepareStatement(sqlB, Statement.RETURN_GENERATED_KEYS);
        }
        return pstmtB;
      }
      return null;
    }

    final static String createPOSTableSQL = "create CACHED table POS ("
        + "pid INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH " + Integer.MIN_VALUE + ") PRIMARY KEY "
        + ",Fen varchar(96) unique"
        + ",W INTEGER  "
        + ",Draw INTEGER  "
        + ",B INTEGER "
        + ");";

    final static String createPOS_MOVESTableSQL = "create CACHED table POS_MOVES ("
        + "pmid INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH " + Integer.MIN_VALUE + ") PRIMARY KEY "
        + ",PFen INTEGER "
        + ",CFen INTEGER "
        + ",Move SMALLINT "
        + ",UNIQUE(PFen,Move,CFen) "
        + ");";

    final static String sqlW = "MERGE INTO POS as t "
        + " USING (VALUES( ? ))" + " AS v(fen)"
        + " ON t.Fen=v.fen"
        + " WHEN MATCHED THEN"
        + "   UPDATE SET t.W=t.W+1"
        + " WHEN NOT MATCHED THEN"
        + "   INSERT VALUES DEFAULT, v.fen, 1,0,0;";

    final static String sqlD = "MERGE INTO POS as t "
        + " USING (VALUES( ? ))" + " AS v(fen)"
        + " ON t.Fen=v.fen"
        + " WHEN MATCHED THEN"
        + "   UPDATE SET t.Draw=t.Draw+1"
        + " WHEN NOT MATCHED THEN"
        + "   INSERT VALUES DEFAULT, v.fen, 0,1,0;";

    final static String sqlB = "MERGE INTO POS as t "
        + " USING (VALUES( ? ))" + " AS v(fen)"
        + " ON t.Fen=v.fen"
        + " WHEN MATCHED THEN"
        + "   UPDATE SET t.B=t.B+1"
        + " WHEN NOT MATCHED THEN"
        + "   INSERT VALUES DEFAULT, v.fen, 0,0,1;";

    final static String sqlM = "MERGE INTO POS_MOVES as t USING (VALUES(?,?,?))"
        + "AS vals(parent, child, move) on t.PFen=vals.parent AND t.CFen=vals.child AND t.Move=vals.move "
        + "WHEN NOT MATCHED THEN INSERT VALUES DEFAULT ,vals.parent, vals.child, vals.move";

    public void storeMoves(List<Utils.Triple<String, Short, String>> movesToStore,
        GameResult result)
        throws SQLException {

      PreparedStatement pstmt = getStatment(result);
      
      if (pstmtM==null) {
        pstmtM = getConnection().prepareStatement(sqlM);
      }

      for (Utils.Triple<String, Short, String> triple : movesToStore) {
        pstmt.setString(1, triple.z);
        pstmt.addBatch();
      }

      try {
        int[] res = pstmt.executeBatch();
      } catch (SQLException e) {
        e.printStackTrace();
        System.out.println(movesToStore.toString());
      }
      ResultSet rs = pstmt.getGeneratedKeys();
      Integer oldPosId = null;
      for (Utils.Triple<String, Short, String> triple : movesToStore) {
        rs.next();
        Integer newPosId = rs.getInt(1);
        if (oldPosId != null) {
          pstmtM.setInt(1, oldPosId);
          pstmtM.setInt(2, newPosId);
          pstmtM.setShort(3, triple.y);
          pstmtM.addBatch();
        }
        oldPosId = newPosId;
      } 
      pstmtM.executeBatch();
    }

  }

}
